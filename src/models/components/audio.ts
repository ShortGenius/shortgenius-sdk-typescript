/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Voice,
  Voice$inboundSchema,
  Voice$Outbound,
  Voice$outboundSchema,
} from "./voice.js";

export type Words = {
  text: string;
  start: number;
  end: number;
  confidence?: number | undefined;
};

/**
 * Transcript of the audio with timestamps. Only available after the audio is generated.
 */
export type Transcript = {
  words: Array<Words>;
};

/**
 * State of the audio generation.
 */
export const AudioState = {
  Pending: "pending",
  Generating: "generating",
  Completed: "completed",
  Error: "error",
} as const;
/**
 * State of the audio generation.
 */
export type AudioState = ClosedEnum<typeof AudioState>;

/**
 * Locale of the audio to guide the AI. Auto-detected if not provided.
 */
export const AudioLocale = {
  AfZA: "af-ZA",
  IDID: "id-ID",
  MsMY: "ms-MY",
  CaES: "ca-ES",
  CsCZ: "cs-CZ",
  DaDK: "da-DK",
  DEDE: "de-DE",
  EnUS: "en-US",
  ESES: "es-ES",
  Es419: "es-419",
  FrCA: "fr-CA",
  FRFR: "fr-FR",
  HRHR: "hr-HR",
  ITIT: "it-IT",
  HUHU: "hu-HU",
  NLNL: "nl-NL",
  NONO: "no-NO",
  PLPL: "pl-PL",
  PtBR: "pt-BR",
  PTPT: "pt-PT",
  RORO: "ro-RO",
  SKSK: "sk-SK",
  FIFI: "fi-FI",
  SvSE: "sv-SE",
  ViVN: "vi-VN",
  TRTR: "tr-TR",
  ElGR: "el-GR",
  RURU: "ru-RU",
  SrSP: "sr-SP",
  UkUA: "uk-UA",
  HyAM: "hy-AM",
  HeIL: "he-IL",
  UrPK: "ur-PK",
  ArSA: "ar-SA",
  HiIN: "hi-IN",
  THTH: "th-TH",
  KoKR: "ko-KR",
  JaJP: "ja-JP",
  ZhCN: "zh-CN",
  ZhTW: "zh-TW",
} as const;
/**
 * Locale of the audio to guide the AI. Auto-detected if not provided.
 */
export type AudioLocale = ClosedEnum<typeof AudioLocale>;

/**
 * Details about the created or retrieved audio media.
 */
export type Audio = {
  /**
   * Unique ID of the audio.
   */
  id: string;
  /**
   * Date and time (ISO 8601) when the audio media was created.
   */
  createdAt: string;
  /**
   * Date and time (ISO 8601) when the audio media was last updated.
   */
  updatedAt?: string | null | undefined;
  /**
   * URL of the audio. Only available after the audio is generated.
   */
  url: string | null;
  /**
   * ID of the user who generated the audio.
   */
  userId: string;
  /**
   * Transcript of the audio with timestamps. Only available after the audio is generated.
   */
  transcript?: Transcript | null | undefined;
  /**
   * State of the audio generation.
   */
  state: AudioState;
  /**
   * Source text of the audio.
   */
  text: string;
  /**
   * Locale of the audio to guide the AI. Auto-detected if not provided.
   */
  locale?: AudioLocale | undefined;
  /**
   * A text-to-speech voice
   */
  voice: Voice;
  /**
   * Duration of the generated audio. Only available after the audio is generated.
   */
  duration?: number | null | undefined;
  /**
   * Loudness normalization value in LUFS. Only available after the audio is generated.
   */
  lufs?: number | null | undefined;
};

/** @internal */
export const Words$inboundSchema: z.ZodType<Words, z.ZodTypeDef, unknown> = z
  .object({
    text: z.string(),
    start: z.number(),
    end: z.number(),
    confidence: z.number().optional(),
  });

/** @internal */
export type Words$Outbound = {
  text: string;
  start: number;
  end: number;
  confidence?: number | undefined;
};

/** @internal */
export const Words$outboundSchema: z.ZodType<
  Words$Outbound,
  z.ZodTypeDef,
  Words
> = z.object({
  text: z.string(),
  start: z.number(),
  end: z.number(),
  confidence: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Words$ {
  /** @deprecated use `Words$inboundSchema` instead. */
  export const inboundSchema = Words$inboundSchema;
  /** @deprecated use `Words$outboundSchema` instead. */
  export const outboundSchema = Words$outboundSchema;
  /** @deprecated use `Words$Outbound` instead. */
  export type Outbound = Words$Outbound;
}

export function wordsToJSON(words: Words): string {
  return JSON.stringify(Words$outboundSchema.parse(words));
}

export function wordsFromJSON(
  jsonString: string,
): SafeParseResult<Words, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Words$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Words' from JSON`,
  );
}

/** @internal */
export const Transcript$inboundSchema: z.ZodType<
  Transcript,
  z.ZodTypeDef,
  unknown
> = z.object({
  words: z.array(z.lazy(() => Words$inboundSchema)),
});

/** @internal */
export type Transcript$Outbound = {
  words: Array<Words$Outbound>;
};

/** @internal */
export const Transcript$outboundSchema: z.ZodType<
  Transcript$Outbound,
  z.ZodTypeDef,
  Transcript
> = z.object({
  words: z.array(z.lazy(() => Words$outboundSchema)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Transcript$ {
  /** @deprecated use `Transcript$inboundSchema` instead. */
  export const inboundSchema = Transcript$inboundSchema;
  /** @deprecated use `Transcript$outboundSchema` instead. */
  export const outboundSchema = Transcript$outboundSchema;
  /** @deprecated use `Transcript$Outbound` instead. */
  export type Outbound = Transcript$Outbound;
}

export function transcriptToJSON(transcript: Transcript): string {
  return JSON.stringify(Transcript$outboundSchema.parse(transcript));
}

export function transcriptFromJSON(
  jsonString: string,
): SafeParseResult<Transcript, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Transcript$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Transcript' from JSON`,
  );
}

/** @internal */
export const AudioState$inboundSchema: z.ZodNativeEnum<typeof AudioState> = z
  .nativeEnum(AudioState);

/** @internal */
export const AudioState$outboundSchema: z.ZodNativeEnum<typeof AudioState> =
  AudioState$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AudioState$ {
  /** @deprecated use `AudioState$inboundSchema` instead. */
  export const inboundSchema = AudioState$inboundSchema;
  /** @deprecated use `AudioState$outboundSchema` instead. */
  export const outboundSchema = AudioState$outboundSchema;
}

/** @internal */
export const AudioLocale$inboundSchema: z.ZodNativeEnum<typeof AudioLocale> = z
  .nativeEnum(AudioLocale);

/** @internal */
export const AudioLocale$outboundSchema: z.ZodNativeEnum<typeof AudioLocale> =
  AudioLocale$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AudioLocale$ {
  /** @deprecated use `AudioLocale$inboundSchema` instead. */
  export const inboundSchema = AudioLocale$inboundSchema;
  /** @deprecated use `AudioLocale$outboundSchema` instead. */
  export const outboundSchema = AudioLocale$outboundSchema;
}

/** @internal */
export const Audio$inboundSchema: z.ZodType<Audio, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    created_at: z.string(),
    updated_at: z.nullable(z.string()).optional(),
    url: z.nullable(z.string()),
    user_id: z.string(),
    transcript: z.nullable(z.lazy(() => Transcript$inboundSchema)).optional(),
    state: AudioState$inboundSchema,
    text: z.string(),
    locale: AudioLocale$inboundSchema.optional(),
    voice: Voice$inboundSchema,
    duration: z.nullable(z.number()).optional(),
    lufs: z.nullable(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "created_at": "createdAt",
      "updated_at": "updatedAt",
      "user_id": "userId",
    });
  });

/** @internal */
export type Audio$Outbound = {
  id: string;
  created_at: string;
  updated_at?: string | null | undefined;
  url: string | null;
  user_id: string;
  transcript?: Transcript$Outbound | null | undefined;
  state: string;
  text: string;
  locale?: string | undefined;
  voice: Voice$Outbound;
  duration?: number | null | undefined;
  lufs?: number | null | undefined;
};

/** @internal */
export const Audio$outboundSchema: z.ZodType<
  Audio$Outbound,
  z.ZodTypeDef,
  Audio
> = z.object({
  id: z.string(),
  createdAt: z.string(),
  updatedAt: z.nullable(z.string()).optional(),
  url: z.nullable(z.string()),
  userId: z.string(),
  transcript: z.nullable(z.lazy(() => Transcript$outboundSchema)).optional(),
  state: AudioState$outboundSchema,
  text: z.string(),
  locale: AudioLocale$outboundSchema.optional(),
  voice: Voice$outboundSchema,
  duration: z.nullable(z.number()).optional(),
  lufs: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    createdAt: "created_at",
    updatedAt: "updated_at",
    userId: "user_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Audio$ {
  /** @deprecated use `Audio$inboundSchema` instead. */
  export const inboundSchema = Audio$inboundSchema;
  /** @deprecated use `Audio$outboundSchema` instead. */
  export const outboundSchema = Audio$outboundSchema;
  /** @deprecated use `Audio$Outbound` instead. */
  export type Outbound = Audio$Outbound;
}

export function audioToJSON(audio: Audio): string {
  return JSON.stringify(Audio$outboundSchema.parse(audio));
}

export function audioFromJSON(
  jsonString: string,
): SafeParseResult<Audio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Audio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Audio' from JSON`,
  );
}
