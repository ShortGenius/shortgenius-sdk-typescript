/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const ContentType = {
  Custom: "Custom",
  News: "News",
  Quiz: "Quiz",
  History: "History",
  Scary: "Scary",
  Motivational: "Motivational",
  Bedtime: "Bedtime",
  FunFacts: "FunFacts",
  LifeTips: "LifeTips",
  Eli5: "ELI5",
  Philosophy: "Philosophy",
} as const;
export type ContentType = ClosedEnum<typeof ContentType>;

/**
 * Locale for the generated video.
 */
export const CreateVideoLocale = {
  AfZA: "af-ZA",
  IDID: "id-ID",
  MsMY: "ms-MY",
  CaES: "ca-ES",
  CsCZ: "cs-CZ",
  DaDK: "da-DK",
  DEDE: "de-DE",
  EnUS: "en-US",
  ESES: "es-ES",
  Es419: "es-419",
  FrCA: "fr-CA",
  FRFR: "fr-FR",
  HRHR: "hr-HR",
  ITIT: "it-IT",
  HUHU: "hu-HU",
  NLNL: "nl-NL",
  NONO: "no-NO",
  PLPL: "pl-PL",
  PtBR: "pt-BR",
  PTPT: "pt-PT",
  RORO: "ro-RO",
  SKSK: "sk-SK",
  FIFI: "fi-FI",
  SvSE: "sv-SE",
  ViVN: "vi-VN",
  TRTR: "tr-TR",
  ElGR: "el-GR",
  RURU: "ru-RU",
  SrSP: "sr-SP",
  UkUA: "uk-UA",
  HyAM: "hy-AM",
  HeIL: "he-IL",
  UrPK: "ur-PK",
  ArSA: "ar-SA",
  HiIN: "hi-IN",
  THTH: "th-TH",
  KoKR: "ko-KR",
  JaJP: "ja-JP",
  ZhCN: "zh-CN",
  ZhTW: "zh-TW",
  Auto: "auto",
} as const;
/**
 * Locale for the generated video.
 */
export type CreateVideoLocale = ClosedEnum<typeof CreateVideoLocale>;

/**
 * Aspect ratio of the video. Not required for News videos.
 */
export const AspectRatio = {
  Nine16: "9:16",
  Sixteen9: "16:9",
  One1: "1:1",
} as const;
/**
 * Aspect ratio of the video. Not required for News videos.
 */
export type AspectRatio = ClosedEnum<typeof AspectRatio>;

export type Options = {
  text: string;
  correct: boolean;
};

export type Questions = {
  /**
   * A quiz question.
   */
  question: string;
  options: Array<Options>;
};

export type Categories = {
  /**
   * The number of questions viewers in this category got right (e.g., "1-2").
   */
  scoreRange: string;
  /**
   * The title of the category.
   */
  title: string;
};

export type Results = {
  /**
   * The header shown at the top of the quiz results.
   */
  header: string;
  /**
   * The text the AI narrates when showing the quiz results.
   */
  explanation: string;
  categories: Array<Categories>;
};

/**
 * Quiz content to be converted into a single video. Required for Quiz videos.
 */
export type Quiz = {
  questions: Array<Questions>;
  results: Results;
};

export type CreateVideoRequestBody = {
  contentType?: ContentType | undefined;
  /**
   * Locale for the generated video.
   */
  locale?: CreateVideoLocale | undefined;
  /**
   * The ID of the image style to use. Use the [List image styles](#tag/images/GET/presets/{type}) endpoint to get a list of available image styles. If left empty, the AI chooses.
   */
  imageStyleId?: string | undefined;
  /**
   * List of publishing connection ids. Use the [List connections](#tag/connections/GET) endpoint to get a list of available connections
   */
  connectionIds: Array<string>;
  /**
   * Aspect ratio of the video. Not required for News videos.
   */
  aspectRatio?: AspectRatio | undefined;
  /**
   * Voice playback speed percentage.
   */
  voicePlaybackRate?: number | undefined;
  /**
   * Voice volume percentage.
   */
  voiceVolume?: number | undefined;
  /**
   * Soundtrack playback speed percentage.
   */
  soundtrackPlaybackRate?: number | undefined;
  /**
   * Soundtrack volume percentage.
   */
  soundtrackVolume?: number | undefined;
  /**
   * The title of the video.
   */
  title: string;
  /**
   * The description shown beside the video when posted to social media.
   */
  caption: string;
  /**
   * A list of scenes that make up the video. Not required for Quiz videos
   */
  scenes?: Array<components.DraftScene> | undefined;
  /**
   * Quiz content to be converted into a single video. Required for Quiz videos.
   */
  quiz?: Quiz | undefined;
  /**
   * The voice to use for speech generation. See the [List voices](#tag/voices/GET/voices) endpoint. If left empty, the AI chooses.
   */
  voiceId?: string | undefined;
  /**
   * Id of the soundtrack to use for background music. See the [List music](#tag/music/GET/music/genres) endpoint for available genres, and the [List music tracks](#tag/music/GET/music/tracks) endpoint for available soundtracks. If left empty, the AI chooses.
   */
  soundtrackId?: string | undefined;
  /**
   * Scheduled time for publishing the video. Format in ISO 8601. If left empty, it will be published 1 hour after the video is created.
   */
  publishAt?: string | undefined;
};

/** @internal */
export const ContentType$inboundSchema: z.ZodNativeEnum<typeof ContentType> = z
  .nativeEnum(ContentType);

/** @internal */
export const ContentType$outboundSchema: z.ZodNativeEnum<typeof ContentType> =
  ContentType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentType$ {
  /** @deprecated use `ContentType$inboundSchema` instead. */
  export const inboundSchema = ContentType$inboundSchema;
  /** @deprecated use `ContentType$outboundSchema` instead. */
  export const outboundSchema = ContentType$outboundSchema;
}

/** @internal */
export const CreateVideoLocale$inboundSchema: z.ZodNativeEnum<
  typeof CreateVideoLocale
> = z.nativeEnum(CreateVideoLocale);

/** @internal */
export const CreateVideoLocale$outboundSchema: z.ZodNativeEnum<
  typeof CreateVideoLocale
> = CreateVideoLocale$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateVideoLocale$ {
  /** @deprecated use `CreateVideoLocale$inboundSchema` instead. */
  export const inboundSchema = CreateVideoLocale$inboundSchema;
  /** @deprecated use `CreateVideoLocale$outboundSchema` instead. */
  export const outboundSchema = CreateVideoLocale$outboundSchema;
}

/** @internal */
export const AspectRatio$inboundSchema: z.ZodNativeEnum<typeof AspectRatio> = z
  .nativeEnum(AspectRatio);

/** @internal */
export const AspectRatio$outboundSchema: z.ZodNativeEnum<typeof AspectRatio> =
  AspectRatio$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AspectRatio$ {
  /** @deprecated use `AspectRatio$inboundSchema` instead. */
  export const inboundSchema = AspectRatio$inboundSchema;
  /** @deprecated use `AspectRatio$outboundSchema` instead. */
  export const outboundSchema = AspectRatio$outboundSchema;
}

/** @internal */
export const Options$inboundSchema: z.ZodType<Options, z.ZodTypeDef, unknown> =
  z.object({
    text: z.string(),
    correct: z.boolean(),
  });

/** @internal */
export type Options$Outbound = {
  text: string;
  correct: boolean;
};

/** @internal */
export const Options$outboundSchema: z.ZodType<
  Options$Outbound,
  z.ZodTypeDef,
  Options
> = z.object({
  text: z.string(),
  correct: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Options$ {
  /** @deprecated use `Options$inboundSchema` instead. */
  export const inboundSchema = Options$inboundSchema;
  /** @deprecated use `Options$outboundSchema` instead. */
  export const outboundSchema = Options$outboundSchema;
  /** @deprecated use `Options$Outbound` instead. */
  export type Outbound = Options$Outbound;
}

export function optionsToJSON(options: Options): string {
  return JSON.stringify(Options$outboundSchema.parse(options));
}

export function optionsFromJSON(
  jsonString: string,
): SafeParseResult<Options, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Options$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Options' from JSON`,
  );
}

/** @internal */
export const Questions$inboundSchema: z.ZodType<
  Questions,
  z.ZodTypeDef,
  unknown
> = z.object({
  question: z.string(),
  options: z.array(z.lazy(() => Options$inboundSchema)),
});

/** @internal */
export type Questions$Outbound = {
  question: string;
  options: Array<Options$Outbound>;
};

/** @internal */
export const Questions$outboundSchema: z.ZodType<
  Questions$Outbound,
  z.ZodTypeDef,
  Questions
> = z.object({
  question: z.string(),
  options: z.array(z.lazy(() => Options$outboundSchema)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Questions$ {
  /** @deprecated use `Questions$inboundSchema` instead. */
  export const inboundSchema = Questions$inboundSchema;
  /** @deprecated use `Questions$outboundSchema` instead. */
  export const outboundSchema = Questions$outboundSchema;
  /** @deprecated use `Questions$Outbound` instead. */
  export type Outbound = Questions$Outbound;
}

export function questionsToJSON(questions: Questions): string {
  return JSON.stringify(Questions$outboundSchema.parse(questions));
}

export function questionsFromJSON(
  jsonString: string,
): SafeParseResult<Questions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Questions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Questions' from JSON`,
  );
}

/** @internal */
export const Categories$inboundSchema: z.ZodType<
  Categories,
  z.ZodTypeDef,
  unknown
> = z.object({
  score_range: z.string(),
  title: z.string(),
}).transform((v) => {
  return remap$(v, {
    "score_range": "scoreRange",
  });
});

/** @internal */
export type Categories$Outbound = {
  score_range: string;
  title: string;
};

/** @internal */
export const Categories$outboundSchema: z.ZodType<
  Categories$Outbound,
  z.ZodTypeDef,
  Categories
> = z.object({
  scoreRange: z.string(),
  title: z.string(),
}).transform((v) => {
  return remap$(v, {
    scoreRange: "score_range",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Categories$ {
  /** @deprecated use `Categories$inboundSchema` instead. */
  export const inboundSchema = Categories$inboundSchema;
  /** @deprecated use `Categories$outboundSchema` instead. */
  export const outboundSchema = Categories$outboundSchema;
  /** @deprecated use `Categories$Outbound` instead. */
  export type Outbound = Categories$Outbound;
}

export function categoriesToJSON(categories: Categories): string {
  return JSON.stringify(Categories$outboundSchema.parse(categories));
}

export function categoriesFromJSON(
  jsonString: string,
): SafeParseResult<Categories, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Categories$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Categories' from JSON`,
  );
}

/** @internal */
export const Results$inboundSchema: z.ZodType<Results, z.ZodTypeDef, unknown> =
  z.object({
    header: z.string(),
    explanation: z.string(),
    categories: z.array(z.lazy(() => Categories$inboundSchema)),
  });

/** @internal */
export type Results$Outbound = {
  header: string;
  explanation: string;
  categories: Array<Categories$Outbound>;
};

/** @internal */
export const Results$outboundSchema: z.ZodType<
  Results$Outbound,
  z.ZodTypeDef,
  Results
> = z.object({
  header: z.string(),
  explanation: z.string(),
  categories: z.array(z.lazy(() => Categories$outboundSchema)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Results$ {
  /** @deprecated use `Results$inboundSchema` instead. */
  export const inboundSchema = Results$inboundSchema;
  /** @deprecated use `Results$outboundSchema` instead. */
  export const outboundSchema = Results$outboundSchema;
  /** @deprecated use `Results$Outbound` instead. */
  export type Outbound = Results$Outbound;
}

export function resultsToJSON(results: Results): string {
  return JSON.stringify(Results$outboundSchema.parse(results));
}

export function resultsFromJSON(
  jsonString: string,
): SafeParseResult<Results, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Results$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Results' from JSON`,
  );
}

/** @internal */
export const Quiz$inboundSchema: z.ZodType<Quiz, z.ZodTypeDef, unknown> = z
  .object({
    questions: z.array(z.lazy(() => Questions$inboundSchema)),
    results: z.lazy(() => Results$inboundSchema),
  });

/** @internal */
export type Quiz$Outbound = {
  questions: Array<Questions$Outbound>;
  results: Results$Outbound;
};

/** @internal */
export const Quiz$outboundSchema: z.ZodType<Quiz$Outbound, z.ZodTypeDef, Quiz> =
  z.object({
    questions: z.array(z.lazy(() => Questions$outboundSchema)),
    results: z.lazy(() => Results$outboundSchema),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Quiz$ {
  /** @deprecated use `Quiz$inboundSchema` instead. */
  export const inboundSchema = Quiz$inboundSchema;
  /** @deprecated use `Quiz$outboundSchema` instead. */
  export const outboundSchema = Quiz$outboundSchema;
  /** @deprecated use `Quiz$Outbound` instead. */
  export type Outbound = Quiz$Outbound;
}

export function quizToJSON(quiz: Quiz): string {
  return JSON.stringify(Quiz$outboundSchema.parse(quiz));
}

export function quizFromJSON(
  jsonString: string,
): SafeParseResult<Quiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Quiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Quiz' from JSON`,
  );
}

/** @internal */
export const CreateVideoRequestBody$inboundSchema: z.ZodType<
  CreateVideoRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  content_type: ContentType$inboundSchema.default("Custom"),
  locale: CreateVideoLocale$inboundSchema.default("auto"),
  image_style_id: z.string().optional(),
  connection_ids: z.array(z.string()),
  aspect_ratio: AspectRatio$inboundSchema.default("9:16"),
  voice_playback_rate: z.number().default(100),
  voice_volume: z.number().default(100),
  soundtrack_playback_rate: z.number().default(100),
  soundtrack_volume: z.number().default(100),
  title: z.string(),
  caption: z.string(),
  scenes: z.array(components.DraftScene$inboundSchema).optional(),
  quiz: z.lazy(() => Quiz$inboundSchema).optional(),
  voice_id: z.string().optional(),
  soundtrack_id: z.string().optional(),
  publish_at: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "content_type": "contentType",
    "image_style_id": "imageStyleId",
    "connection_ids": "connectionIds",
    "aspect_ratio": "aspectRatio",
    "voice_playback_rate": "voicePlaybackRate",
    "voice_volume": "voiceVolume",
    "soundtrack_playback_rate": "soundtrackPlaybackRate",
    "soundtrack_volume": "soundtrackVolume",
    "voice_id": "voiceId",
    "soundtrack_id": "soundtrackId",
    "publish_at": "publishAt",
  });
});

/** @internal */
export type CreateVideoRequestBody$Outbound = {
  content_type: string;
  locale: string;
  image_style_id?: string | undefined;
  connection_ids: Array<string>;
  aspect_ratio: string;
  voice_playback_rate: number;
  voice_volume: number;
  soundtrack_playback_rate: number;
  soundtrack_volume: number;
  title: string;
  caption: string;
  scenes?: Array<components.DraftScene$Outbound> | undefined;
  quiz?: Quiz$Outbound | undefined;
  voice_id?: string | undefined;
  soundtrack_id?: string | undefined;
  publish_at?: string | undefined;
};

/** @internal */
export const CreateVideoRequestBody$outboundSchema: z.ZodType<
  CreateVideoRequestBody$Outbound,
  z.ZodTypeDef,
  CreateVideoRequestBody
> = z.object({
  contentType: ContentType$outboundSchema.default("Custom"),
  locale: CreateVideoLocale$outboundSchema.default("auto"),
  imageStyleId: z.string().optional(),
  connectionIds: z.array(z.string()),
  aspectRatio: AspectRatio$outboundSchema.default("9:16"),
  voicePlaybackRate: z.number().default(100),
  voiceVolume: z.number().default(100),
  soundtrackPlaybackRate: z.number().default(100),
  soundtrackVolume: z.number().default(100),
  title: z.string(),
  caption: z.string(),
  scenes: z.array(components.DraftScene$outboundSchema).optional(),
  quiz: z.lazy(() => Quiz$outboundSchema).optional(),
  voiceId: z.string().optional(),
  soundtrackId: z.string().optional(),
  publishAt: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    contentType: "content_type",
    imageStyleId: "image_style_id",
    connectionIds: "connection_ids",
    aspectRatio: "aspect_ratio",
    voicePlaybackRate: "voice_playback_rate",
    voiceVolume: "voice_volume",
    soundtrackPlaybackRate: "soundtrack_playback_rate",
    soundtrackVolume: "soundtrack_volume",
    voiceId: "voice_id",
    soundtrackId: "soundtrack_id",
    publishAt: "publish_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateVideoRequestBody$ {
  /** @deprecated use `CreateVideoRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateVideoRequestBody$inboundSchema;
  /** @deprecated use `CreateVideoRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateVideoRequestBody$outboundSchema;
  /** @deprecated use `CreateVideoRequestBody$Outbound` instead. */
  export type Outbound = CreateVideoRequestBody$Outbound;
}

export function createVideoRequestBodyToJSON(
  createVideoRequestBody: CreateVideoRequestBody,
): string {
  return JSON.stringify(
    CreateVideoRequestBody$outboundSchema.parse(createVideoRequestBody),
  );
}

export function createVideoRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateVideoRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateVideoRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateVideoRequestBody' from JSON`,
  );
}
