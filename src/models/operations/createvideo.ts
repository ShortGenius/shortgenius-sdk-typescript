/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const ContentType = {
  Custom: "Custom",
  News: "News",
  Quiz: "Quiz",
  History: "History",
  Scary: "Scary",
  Motivational: "Motivational",
  Bedtime: "Bedtime",
  FunFacts: "FunFacts",
  LifeTips: "LifeTips",
  Eli5: "ELI5",
  Philosophy: "Philosophy",
  Ad: "Ad",
} as const;
export type ContentType = ClosedEnum<typeof ContentType>;

/**
 * Locale for the generated video.
 */
export const CreateVideoLocale = {
  AfZA: "af-ZA",
  IDID: "id-ID",
  MsMY: "ms-MY",
  CaES: "ca-ES",
  CsCZ: "cs-CZ",
  DaDK: "da-DK",
  DEDE: "de-DE",
  EnUS: "en-US",
  ESES: "es-ES",
  Es419: "es-419",
  FrCA: "fr-CA",
  FRFR: "fr-FR",
  HRHR: "hr-HR",
  ITIT: "it-IT",
  HUHU: "hu-HU",
  NLNL: "nl-NL",
  NONO: "no-NO",
  PLPL: "pl-PL",
  PtBR: "pt-BR",
  PTPT: "pt-PT",
  RORO: "ro-RO",
  SKSK: "sk-SK",
  FIFI: "fi-FI",
  SvSE: "sv-SE",
  ViVN: "vi-VN",
  TRTR: "tr-TR",
  ElGR: "el-GR",
  RURU: "ru-RU",
  SrSP: "sr-SP",
  UkUA: "uk-UA",
  HyAM: "hy-AM",
  HeIL: "he-IL",
  UrPK: "ur-PK",
  ArSA: "ar-SA",
  HiIN: "hi-IN",
  THTH: "th-TH",
  KoKR: "ko-KR",
  JaJP: "ja-JP",
  ZhCN: "zh-CN",
  ZhTW: "zh-TW",
  Auto: "auto",
} as const;
/**
 * Locale for the generated video.
 */
export type CreateVideoLocale = ClosedEnum<typeof CreateVideoLocale>;

/**
 * Image model for the generated video.
 */
export const ImageModel = {
  OpenAI: "OpenAI",
  FluxUltraMax: "Flux Ultra/Max",
  FluxPro: "Flux Pro",
} as const;
/**
 * Image model for the generated video.
 */
export type ImageModel = ClosedEnum<typeof ImageModel>;

/**
 * Image quality for the generated video.
 */
export const ImageQuality = {
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Image quality for the generated video.
 */
export type ImageQuality = ClosedEnum<typeof ImageQuality>;

/**
 * Default animation model for scene images when not specified individually.
 */
export const AnimationModel = {
  None: "None",
  Seedance: "Seedance",
  Kling: "Kling",
  Hailuo02Standard: "Hailuo02Standard",
  Hailuo02Pro: "Hailuo02Pro",
  Veo3: "Veo3",
  SeedanceTTV: "SeedanceTTV",
} as const;
/**
 * Default animation model for scene images when not specified individually.
 */
export type AnimationModel = ClosedEnum<typeof AnimationModel>;

/**
 * Default animation preset for scene images when not specified individually.
 */
export const AnimationModelPreset = {
  FullyAnimated: "fully_animated",
  FirstSceneOnly: "first_scene_only",
  FirstImageEachScene: "first_image_each_scene",
} as const;
/**
 * Default animation preset for scene images when not specified individually.
 */
export type AnimationModelPreset = ClosedEnum<typeof AnimationModelPreset>;

/**
 * Aspect ratio of the video. Not required for News videos.
 */
export const AspectRatio = {
  NineHundredAndSixteen: "9:16",
  OneHundredAndSixtyNine: "16:9",
  Eleven: "1:1",
} as const;
/**
 * Aspect ratio of the video. Not required for News videos.
 */
export type AspectRatio = ClosedEnum<typeof AspectRatio>;

export type Options = {
  text: string;
  correct: boolean;
};

export type Questions = {
  /**
   * A quiz question.
   */
  question: string;
  options: Array<Options>;
};

export type Categories = {
  /**
   * The number of questions viewers in this category got right (e.g., "1-2").
   */
  scoreRange: string;
  /**
   * The title of the category.
   */
  title: string;
};

export type Results = {
  /**
   * The header shown at the top of the quiz results.
   */
  header: string;
  /**
   * The text the AI narrates when showing the quiz results.
   */
  explanation: string;
  categories: Array<Categories>;
};

/**
 * Quiz content to be converted into a single video. Required for Quiz videos.
 */
export type Quiz = {
  questions: Array<Questions>;
  results: Results;
};

/**
 * The ad type.
 */
export const Type = {
  JustTheHook: "JustTheHook",
  HookAndVideo: "HookAndVideo",
  HookAndRealVideos: "HookAndRealVideos",
} as const;
/**
 * The ad type.
 */
export type Type = ClosedEnum<typeof Type>;

export type Metadata = {
  sourceImageUrl: string;
  muxPlaybackId: string | null;
};

export const UgcMediaSource = {
  Ugc: "Ugc",
} as const;
export type UgcMediaSource = ClosedEnum<typeof UgcMediaSource>;

export type UgcMediaData = {
  id: string;
  ugcCreatorId: string;
  ugcPresetId: string;
  createdAt: string;
  hook?: string | null | undefined;
};

export const State = {
  Pending: "pending",
  Generating: "generating",
  Completed: "completed",
  Error: "error",
} as const;
export type State = ClosedEnum<typeof State>;

export type Two = {
  url: string | null;
  deletedAt?: string | null | undefined;
  metadata: Metadata;
  lastError?: string | null | undefined;
  type?: "UgcVideo" | undefined;
  source: UgcMediaSource | null;
  category?: "Ugc" | undefined;
  data: UgcMediaData;
  state: State;
};

export const Source = {
  Ugc: "Ugc",
} as const;
export type Source = ClosedEnum<typeof Source>;

export type Data = {
  id: string;
  hook?: string | null | undefined;
};

export type One = {
  url: string | null;
  deletedAt?: string | null | undefined;
  metadata?: any | undefined;
  lastError?: string | null | undefined;
  type?: "UgcCreator" | undefined;
  source: Source | null;
  category?: "Ugc" | undefined;
  data: Data;
  state?: "completed" | undefined;
};

/**
 * The ad UGC media.
 */
export type UgcMedia = Two | One;

/**
 * Ad content to be converted into a single video. Required for Ad videos.
 */
export type Ad = {
  /**
   * The ad product ID.
   */
  productId: string;
  /**
   * The ad type.
   */
  type: Type;
  /**
   * The ad UGC media.
   */
  ugcMedia: Two | One;
  /**
   * The ad media ID. Required for HookAndVideo type.
   */
  mediaId?: string | undefined;
};

export type CreateVideoRequestBody = {
  contentType?: ContentType | undefined;
  /**
   * Locale for the generated video.
   */
  locale?: CreateVideoLocale | undefined;
  /**
   * The ID of the image style to use. Use the [List image styles](#tag/images/GET/presets/{type}) endpoint to get a list of available image styles. If left empty, the AI chooses.
   */
  imageStyleId?: string | undefined;
  /**
   * Image model for the generated video.
   */
  imageModel?: ImageModel | undefined;
  /**
   * Image quality for the generated video.
   */
  imageQuality?: ImageQuality | undefined;
  /**
   * Whether to use the raw image style mode. If true, the image style will be ignored.
   */
  imageStyleRawMode?: boolean | undefined;
  /**
   * Custom prompt for the image style. If you provide a custom prompt, the image style will be ignored.
   */
  imageStyleCustomPrompt?: string | undefined;
  /**
   * Default animation model for scene images when not specified individually.
   */
  animationModel?: AnimationModel | undefined;
  /**
   * Default animation preset for scene images when not specified individually.
   */
  animationModelPreset?: AnimationModelPreset | undefined;
  /**
   * List of publishing connection ids. Use the [List connections](#tag/connections/GET) endpoint to get a list of available connections
   */
  connectionIds: Array<string>;
  /**
   * Aspect ratio of the video. Not required for News videos.
   */
  aspectRatio?: AspectRatio | undefined;
  /**
   * Voice playback speed percentage.
   */
  voicePlaybackRate?: number | undefined;
  /**
   * Voice volume percentage.
   */
  voiceVolume?: number | undefined;
  /**
   * Soundtrack playback speed percentage.
   */
  soundtrackPlaybackRate?: number | undefined;
  /**
   * Soundtrack volume percentage.
   */
  soundtrackVolume?: number | undefined;
  /**
   * The title of the video.
   */
  title: string;
  /**
   * The description shown beside the video when posted to social media.
   */
  caption: string;
  /**
   * A list of scenes that make up the video. Not required for Quiz videos
   */
  scenes?: Array<components.DraftScene> | undefined;
  /**
   * Quiz content to be converted into a single video. Required for Quiz videos.
   */
  quiz?: Quiz | undefined;
  /**
   * Ad content to be converted into a single video. Required for Ad videos.
   */
  ad?: Ad | undefined;
  /**
   * The voice to use for speech generation. See the [List voices](#tag/voices/GET/voices) endpoint. If left empty, the AI chooses.
   */
  voiceId?: string | undefined;
  /**
   * Id of the soundtrack to use for background music. See the [List music](#tag/music/GET/music/genres) endpoint for available genres, and the [List music tracks](#tag/music/GET/music/tracks) endpoint for available soundtracks. If left empty, the AI chooses.
   */
  soundtrackId?: string | undefined;
  /**
   * Scheduled time for publishing the video. Format in ISO 8601. If left empty, it will be published 1 hour after the video is created.
   */
  publishAt?: string | undefined;
};

/** @internal */
export const ContentType$inboundSchema: z.ZodNativeEnum<typeof ContentType> = z
  .nativeEnum(ContentType);

/** @internal */
export const ContentType$outboundSchema: z.ZodNativeEnum<typeof ContentType> =
  ContentType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentType$ {
  /** @deprecated use `ContentType$inboundSchema` instead. */
  export const inboundSchema = ContentType$inboundSchema;
  /** @deprecated use `ContentType$outboundSchema` instead. */
  export const outboundSchema = ContentType$outboundSchema;
}

/** @internal */
export const CreateVideoLocale$inboundSchema: z.ZodNativeEnum<
  typeof CreateVideoLocale
> = z.nativeEnum(CreateVideoLocale);

/** @internal */
export const CreateVideoLocale$outboundSchema: z.ZodNativeEnum<
  typeof CreateVideoLocale
> = CreateVideoLocale$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateVideoLocale$ {
  /** @deprecated use `CreateVideoLocale$inboundSchema` instead. */
  export const inboundSchema = CreateVideoLocale$inboundSchema;
  /** @deprecated use `CreateVideoLocale$outboundSchema` instead. */
  export const outboundSchema = CreateVideoLocale$outboundSchema;
}

/** @internal */
export const ImageModel$inboundSchema: z.ZodNativeEnum<typeof ImageModel> = z
  .nativeEnum(ImageModel);

/** @internal */
export const ImageModel$outboundSchema: z.ZodNativeEnum<typeof ImageModel> =
  ImageModel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ImageModel$ {
  /** @deprecated use `ImageModel$inboundSchema` instead. */
  export const inboundSchema = ImageModel$inboundSchema;
  /** @deprecated use `ImageModel$outboundSchema` instead. */
  export const outboundSchema = ImageModel$outboundSchema;
}

/** @internal */
export const ImageQuality$inboundSchema: z.ZodNativeEnum<typeof ImageQuality> =
  z.nativeEnum(ImageQuality);

/** @internal */
export const ImageQuality$outboundSchema: z.ZodNativeEnum<typeof ImageQuality> =
  ImageQuality$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ImageQuality$ {
  /** @deprecated use `ImageQuality$inboundSchema` instead. */
  export const inboundSchema = ImageQuality$inboundSchema;
  /** @deprecated use `ImageQuality$outboundSchema` instead. */
  export const outboundSchema = ImageQuality$outboundSchema;
}

/** @internal */
export const AnimationModel$inboundSchema: z.ZodNativeEnum<
  typeof AnimationModel
> = z.nativeEnum(AnimationModel);

/** @internal */
export const AnimationModel$outboundSchema: z.ZodNativeEnum<
  typeof AnimationModel
> = AnimationModel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AnimationModel$ {
  /** @deprecated use `AnimationModel$inboundSchema` instead. */
  export const inboundSchema = AnimationModel$inboundSchema;
  /** @deprecated use `AnimationModel$outboundSchema` instead. */
  export const outboundSchema = AnimationModel$outboundSchema;
}

/** @internal */
export const AnimationModelPreset$inboundSchema: z.ZodNativeEnum<
  typeof AnimationModelPreset
> = z.nativeEnum(AnimationModelPreset);

/** @internal */
export const AnimationModelPreset$outboundSchema: z.ZodNativeEnum<
  typeof AnimationModelPreset
> = AnimationModelPreset$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AnimationModelPreset$ {
  /** @deprecated use `AnimationModelPreset$inboundSchema` instead. */
  export const inboundSchema = AnimationModelPreset$inboundSchema;
  /** @deprecated use `AnimationModelPreset$outboundSchema` instead. */
  export const outboundSchema = AnimationModelPreset$outboundSchema;
}

/** @internal */
export const AspectRatio$inboundSchema: z.ZodNativeEnum<typeof AspectRatio> = z
  .nativeEnum(AspectRatio);

/** @internal */
export const AspectRatio$outboundSchema: z.ZodNativeEnum<typeof AspectRatio> =
  AspectRatio$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AspectRatio$ {
  /** @deprecated use `AspectRatio$inboundSchema` instead. */
  export const inboundSchema = AspectRatio$inboundSchema;
  /** @deprecated use `AspectRatio$outboundSchema` instead. */
  export const outboundSchema = AspectRatio$outboundSchema;
}

/** @internal */
export const Options$inboundSchema: z.ZodType<Options, z.ZodTypeDef, unknown> =
  z.object({
    text: z.string(),
    correct: z.boolean(),
  });

/** @internal */
export type Options$Outbound = {
  text: string;
  correct: boolean;
};

/** @internal */
export const Options$outboundSchema: z.ZodType<
  Options$Outbound,
  z.ZodTypeDef,
  Options
> = z.object({
  text: z.string(),
  correct: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Options$ {
  /** @deprecated use `Options$inboundSchema` instead. */
  export const inboundSchema = Options$inboundSchema;
  /** @deprecated use `Options$outboundSchema` instead. */
  export const outboundSchema = Options$outboundSchema;
  /** @deprecated use `Options$Outbound` instead. */
  export type Outbound = Options$Outbound;
}

export function optionsToJSON(options: Options): string {
  return JSON.stringify(Options$outboundSchema.parse(options));
}

export function optionsFromJSON(
  jsonString: string,
): SafeParseResult<Options, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Options$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Options' from JSON`,
  );
}

/** @internal */
export const Questions$inboundSchema: z.ZodType<
  Questions,
  z.ZodTypeDef,
  unknown
> = z.object({
  question: z.string(),
  options: z.array(z.lazy(() => Options$inboundSchema)),
});

/** @internal */
export type Questions$Outbound = {
  question: string;
  options: Array<Options$Outbound>;
};

/** @internal */
export const Questions$outboundSchema: z.ZodType<
  Questions$Outbound,
  z.ZodTypeDef,
  Questions
> = z.object({
  question: z.string(),
  options: z.array(z.lazy(() => Options$outboundSchema)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Questions$ {
  /** @deprecated use `Questions$inboundSchema` instead. */
  export const inboundSchema = Questions$inboundSchema;
  /** @deprecated use `Questions$outboundSchema` instead. */
  export const outboundSchema = Questions$outboundSchema;
  /** @deprecated use `Questions$Outbound` instead. */
  export type Outbound = Questions$Outbound;
}

export function questionsToJSON(questions: Questions): string {
  return JSON.stringify(Questions$outboundSchema.parse(questions));
}

export function questionsFromJSON(
  jsonString: string,
): SafeParseResult<Questions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Questions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Questions' from JSON`,
  );
}

/** @internal */
export const Categories$inboundSchema: z.ZodType<
  Categories,
  z.ZodTypeDef,
  unknown
> = z.object({
  score_range: z.string(),
  title: z.string(),
}).transform((v) => {
  return remap$(v, {
    "score_range": "scoreRange",
  });
});

/** @internal */
export type Categories$Outbound = {
  score_range: string;
  title: string;
};

/** @internal */
export const Categories$outboundSchema: z.ZodType<
  Categories$Outbound,
  z.ZodTypeDef,
  Categories
> = z.object({
  scoreRange: z.string(),
  title: z.string(),
}).transform((v) => {
  return remap$(v, {
    scoreRange: "score_range",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Categories$ {
  /** @deprecated use `Categories$inboundSchema` instead. */
  export const inboundSchema = Categories$inboundSchema;
  /** @deprecated use `Categories$outboundSchema` instead. */
  export const outboundSchema = Categories$outboundSchema;
  /** @deprecated use `Categories$Outbound` instead. */
  export type Outbound = Categories$Outbound;
}

export function categoriesToJSON(categories: Categories): string {
  return JSON.stringify(Categories$outboundSchema.parse(categories));
}

export function categoriesFromJSON(
  jsonString: string,
): SafeParseResult<Categories, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Categories$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Categories' from JSON`,
  );
}

/** @internal */
export const Results$inboundSchema: z.ZodType<Results, z.ZodTypeDef, unknown> =
  z.object({
    header: z.string(),
    explanation: z.string(),
    categories: z.array(z.lazy(() => Categories$inboundSchema)),
  });

/** @internal */
export type Results$Outbound = {
  header: string;
  explanation: string;
  categories: Array<Categories$Outbound>;
};

/** @internal */
export const Results$outboundSchema: z.ZodType<
  Results$Outbound,
  z.ZodTypeDef,
  Results
> = z.object({
  header: z.string(),
  explanation: z.string(),
  categories: z.array(z.lazy(() => Categories$outboundSchema)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Results$ {
  /** @deprecated use `Results$inboundSchema` instead. */
  export const inboundSchema = Results$inboundSchema;
  /** @deprecated use `Results$outboundSchema` instead. */
  export const outboundSchema = Results$outboundSchema;
  /** @deprecated use `Results$Outbound` instead. */
  export type Outbound = Results$Outbound;
}

export function resultsToJSON(results: Results): string {
  return JSON.stringify(Results$outboundSchema.parse(results));
}

export function resultsFromJSON(
  jsonString: string,
): SafeParseResult<Results, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Results$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Results' from JSON`,
  );
}

/** @internal */
export const Quiz$inboundSchema: z.ZodType<Quiz, z.ZodTypeDef, unknown> = z
  .object({
    questions: z.array(z.lazy(() => Questions$inboundSchema)),
    results: z.lazy(() => Results$inboundSchema),
  });

/** @internal */
export type Quiz$Outbound = {
  questions: Array<Questions$Outbound>;
  results: Results$Outbound;
};

/** @internal */
export const Quiz$outboundSchema: z.ZodType<Quiz$Outbound, z.ZodTypeDef, Quiz> =
  z.object({
    questions: z.array(z.lazy(() => Questions$outboundSchema)),
    results: z.lazy(() => Results$outboundSchema),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Quiz$ {
  /** @deprecated use `Quiz$inboundSchema` instead. */
  export const inboundSchema = Quiz$inboundSchema;
  /** @deprecated use `Quiz$outboundSchema` instead. */
  export const outboundSchema = Quiz$outboundSchema;
  /** @deprecated use `Quiz$Outbound` instead. */
  export type Outbound = Quiz$Outbound;
}

export function quizToJSON(quiz: Quiz): string {
  return JSON.stringify(Quiz$outboundSchema.parse(quiz));
}

export function quizFromJSON(
  jsonString: string,
): SafeParseResult<Quiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Quiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Quiz' from JSON`,
  );
}

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);

/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Type$ {
  /** @deprecated use `Type$inboundSchema` instead. */
  export const inboundSchema = Type$inboundSchema;
  /** @deprecated use `Type$outboundSchema` instead. */
  export const outboundSchema = Type$outboundSchema;
}

/** @internal */
export const Metadata$inboundSchema: z.ZodType<
  Metadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  sourceImageUrl: z.string(),
  muxPlaybackId: z.nullable(z.string()),
});

/** @internal */
export type Metadata$Outbound = {
  sourceImageUrl: string;
  muxPlaybackId: string | null;
};

/** @internal */
export const Metadata$outboundSchema: z.ZodType<
  Metadata$Outbound,
  z.ZodTypeDef,
  Metadata
> = z.object({
  sourceImageUrl: z.string(),
  muxPlaybackId: z.nullable(z.string()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Metadata$ {
  /** @deprecated use `Metadata$inboundSchema` instead. */
  export const inboundSchema = Metadata$inboundSchema;
  /** @deprecated use `Metadata$outboundSchema` instead. */
  export const outboundSchema = Metadata$outboundSchema;
  /** @deprecated use `Metadata$Outbound` instead. */
  export type Outbound = Metadata$Outbound;
}

export function metadataToJSON(metadata: Metadata): string {
  return JSON.stringify(Metadata$outboundSchema.parse(metadata));
}

export function metadataFromJSON(
  jsonString: string,
): SafeParseResult<Metadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metadata' from JSON`,
  );
}

/** @internal */
export const UgcMediaSource$inboundSchema: z.ZodNativeEnum<
  typeof UgcMediaSource
> = z.nativeEnum(UgcMediaSource);

/** @internal */
export const UgcMediaSource$outboundSchema: z.ZodNativeEnum<
  typeof UgcMediaSource
> = UgcMediaSource$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UgcMediaSource$ {
  /** @deprecated use `UgcMediaSource$inboundSchema` instead. */
  export const inboundSchema = UgcMediaSource$inboundSchema;
  /** @deprecated use `UgcMediaSource$outboundSchema` instead. */
  export const outboundSchema = UgcMediaSource$outboundSchema;
}

/** @internal */
export const UgcMediaData$inboundSchema: z.ZodType<
  UgcMediaData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  ugcCreatorId: z.string(),
  ugcPresetId: z.string(),
  createdAt: z.string(),
  hook: z.nullable(z.string()).optional(),
});

/** @internal */
export type UgcMediaData$Outbound = {
  id: string;
  ugcCreatorId: string;
  ugcPresetId: string;
  createdAt: string;
  hook?: string | null | undefined;
};

/** @internal */
export const UgcMediaData$outboundSchema: z.ZodType<
  UgcMediaData$Outbound,
  z.ZodTypeDef,
  UgcMediaData
> = z.object({
  id: z.string(),
  ugcCreatorId: z.string(),
  ugcPresetId: z.string(),
  createdAt: z.string(),
  hook: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UgcMediaData$ {
  /** @deprecated use `UgcMediaData$inboundSchema` instead. */
  export const inboundSchema = UgcMediaData$inboundSchema;
  /** @deprecated use `UgcMediaData$outboundSchema` instead. */
  export const outboundSchema = UgcMediaData$outboundSchema;
  /** @deprecated use `UgcMediaData$Outbound` instead. */
  export type Outbound = UgcMediaData$Outbound;
}

export function ugcMediaDataToJSON(ugcMediaData: UgcMediaData): string {
  return JSON.stringify(UgcMediaData$outboundSchema.parse(ugcMediaData));
}

export function ugcMediaDataFromJSON(
  jsonString: string,
): SafeParseResult<UgcMediaData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UgcMediaData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UgcMediaData' from JSON`,
  );
}

/** @internal */
export const State$inboundSchema: z.ZodNativeEnum<typeof State> = z.nativeEnum(
  State,
);

/** @internal */
export const State$outboundSchema: z.ZodNativeEnum<typeof State> =
  State$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace State$ {
  /** @deprecated use `State$inboundSchema` instead. */
  export const inboundSchema = State$inboundSchema;
  /** @deprecated use `State$outboundSchema` instead. */
  export const outboundSchema = State$outboundSchema;
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    url: z.nullable(z.string()),
    deletedAt: z.nullable(z.string()).optional(),
    metadata: z.lazy(() => Metadata$inboundSchema),
    lastError: z.nullable(z.string()).optional(),
    type: z.literal("UgcVideo").default("UgcVideo").optional(),
    source: z.nullable(UgcMediaSource$inboundSchema),
    category: z.literal("Ugc").default("Ugc").optional(),
    data: z.lazy(() => UgcMediaData$inboundSchema),
    state: State$inboundSchema,
  });

/** @internal */
export type Two$Outbound = {
  url: string | null;
  deletedAt?: string | null | undefined;
  metadata: Metadata$Outbound;
  lastError?: string | null | undefined;
  type: "UgcVideo";
  source: string | null;
  category: "Ugc";
  data: UgcMediaData$Outbound;
  state: string;
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    url: z.nullable(z.string()),
    deletedAt: z.nullable(z.string()).optional(),
    metadata: z.lazy(() => Metadata$outboundSchema),
    lastError: z.nullable(z.string()).optional(),
    type: z.literal("UgcVideo").default("UgcVideo" as const),
    source: z.nullable(UgcMediaSource$outboundSchema),
    category: z.literal("Ugc").default("Ugc" as const),
    data: z.lazy(() => UgcMediaData$outboundSchema),
    state: State$outboundSchema,
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const Source$inboundSchema: z.ZodNativeEnum<typeof Source> = z
  .nativeEnum(Source);

/** @internal */
export const Source$outboundSchema: z.ZodNativeEnum<typeof Source> =
  Source$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Source$ {
  /** @deprecated use `Source$inboundSchema` instead. */
  export const inboundSchema = Source$inboundSchema;
  /** @deprecated use `Source$outboundSchema` instead. */
  export const outboundSchema = Source$outboundSchema;
}

/** @internal */
export const Data$inboundSchema: z.ZodType<Data, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    hook: z.nullable(z.string()).optional(),
  });

/** @internal */
export type Data$Outbound = {
  id: string;
  hook?: string | null | undefined;
};

/** @internal */
export const Data$outboundSchema: z.ZodType<Data$Outbound, z.ZodTypeDef, Data> =
  z.object({
    id: z.string(),
    hook: z.nullable(z.string()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Data$ {
  /** @deprecated use `Data$inboundSchema` instead. */
  export const inboundSchema = Data$inboundSchema;
  /** @deprecated use `Data$outboundSchema` instead. */
  export const outboundSchema = Data$outboundSchema;
  /** @deprecated use `Data$Outbound` instead. */
  export type Outbound = Data$Outbound;
}

export function dataToJSON(data: Data): string {
  return JSON.stringify(Data$outboundSchema.parse(data));
}

export function dataFromJSON(
  jsonString: string,
): SafeParseResult<Data, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data' from JSON`,
  );
}

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z
  .object({
    url: z.nullable(z.string()),
    deletedAt: z.nullable(z.string()).optional(),
    metadata: z.any().optional(),
    lastError: z.nullable(z.string()).optional(),
    type: z.literal("UgcCreator").default("UgcCreator").optional(),
    source: z.nullable(Source$inboundSchema),
    category: z.literal("Ugc").default("Ugc").optional(),
    data: z.lazy(() => Data$inboundSchema),
    state: z.literal("completed").default("completed").optional(),
  });

/** @internal */
export type One$Outbound = {
  url: string | null;
  deletedAt?: string | null | undefined;
  metadata?: any | undefined;
  lastError?: string | null | undefined;
  type: "UgcCreator";
  source: string | null;
  category: "Ugc";
  data: Data$Outbound;
  state: "completed";
};

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .object({
    url: z.nullable(z.string()),
    deletedAt: z.nullable(z.string()).optional(),
    metadata: z.any().optional(),
    lastError: z.nullable(z.string()).optional(),
    type: z.literal("UgcCreator").default("UgcCreator" as const),
    source: z.nullable(Source$outboundSchema),
    category: z.literal("Ugc").default("Ugc" as const),
    data: z.lazy(() => Data$outboundSchema),
    state: z.literal("completed").default("completed" as const),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace One$ {
  /** @deprecated use `One$inboundSchema` instead. */
  export const inboundSchema = One$inboundSchema;
  /** @deprecated use `One$outboundSchema` instead. */
  export const outboundSchema = One$outboundSchema;
  /** @deprecated use `One$Outbound` instead. */
  export type Outbound = One$Outbound;
}

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}

export function oneFromJSON(
  jsonString: string,
): SafeParseResult<One, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => One$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'One' from JSON`,
  );
}

/** @internal */
export const UgcMedia$inboundSchema: z.ZodType<
  UgcMedia,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => Two$inboundSchema), z.lazy(() => One$inboundSchema)]);

/** @internal */
export type UgcMedia$Outbound = Two$Outbound | One$Outbound;

/** @internal */
export const UgcMedia$outboundSchema: z.ZodType<
  UgcMedia$Outbound,
  z.ZodTypeDef,
  UgcMedia
> = z.union([
  z.lazy(() => Two$outboundSchema),
  z.lazy(() => One$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UgcMedia$ {
  /** @deprecated use `UgcMedia$inboundSchema` instead. */
  export const inboundSchema = UgcMedia$inboundSchema;
  /** @deprecated use `UgcMedia$outboundSchema` instead. */
  export const outboundSchema = UgcMedia$outboundSchema;
  /** @deprecated use `UgcMedia$Outbound` instead. */
  export type Outbound = UgcMedia$Outbound;
}

export function ugcMediaToJSON(ugcMedia: UgcMedia): string {
  return JSON.stringify(UgcMedia$outboundSchema.parse(ugcMedia));
}

export function ugcMediaFromJSON(
  jsonString: string,
): SafeParseResult<UgcMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UgcMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UgcMedia' from JSON`,
  );
}

/** @internal */
export const Ad$inboundSchema: z.ZodType<Ad, z.ZodTypeDef, unknown> = z.object({
  product_id: z.string(),
  type: Type$inboundSchema,
  ugc_media: z.union([
    z.lazy(() => Two$inboundSchema),
    z.lazy(() => One$inboundSchema),
  ]),
  media_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "product_id": "productId",
    "ugc_media": "ugcMedia",
    "media_id": "mediaId",
  });
});

/** @internal */
export type Ad$Outbound = {
  product_id: string;
  type: string;
  ugc_media: Two$Outbound | One$Outbound;
  media_id?: string | undefined;
};

/** @internal */
export const Ad$outboundSchema: z.ZodType<Ad$Outbound, z.ZodTypeDef, Ad> = z
  .object({
    productId: z.string(),
    type: Type$outboundSchema,
    ugcMedia: z.union([
      z.lazy(() => Two$outboundSchema),
      z.lazy(() => One$outboundSchema),
    ]),
    mediaId: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      productId: "product_id",
      ugcMedia: "ugc_media",
      mediaId: "media_id",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Ad$ {
  /** @deprecated use `Ad$inboundSchema` instead. */
  export const inboundSchema = Ad$inboundSchema;
  /** @deprecated use `Ad$outboundSchema` instead. */
  export const outboundSchema = Ad$outboundSchema;
  /** @deprecated use `Ad$Outbound` instead. */
  export type Outbound = Ad$Outbound;
}

export function adToJSON(ad: Ad): string {
  return JSON.stringify(Ad$outboundSchema.parse(ad));
}

export function adFromJSON(
  jsonString: string,
): SafeParseResult<Ad, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Ad$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Ad' from JSON`,
  );
}

/** @internal */
export const CreateVideoRequestBody$inboundSchema: z.ZodType<
  CreateVideoRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  content_type: ContentType$inboundSchema.default("Custom"),
  locale: CreateVideoLocale$inboundSchema.default("auto"),
  image_style_id: z.string().optional(),
  image_model: ImageModel$inboundSchema.optional(),
  image_quality: ImageQuality$inboundSchema.optional(),
  image_style_raw_mode: z.boolean().optional(),
  image_style_custom_prompt: z.string().optional(),
  animation_model: AnimationModel$inboundSchema.optional(),
  animation_model_preset: AnimationModelPreset$inboundSchema.optional(),
  connection_ids: z.array(z.string()),
  aspect_ratio: AspectRatio$inboundSchema.default("9:16"),
  voice_playback_rate: z.number().default(100),
  voice_volume: z.number().default(100),
  soundtrack_playback_rate: z.number().default(100),
  soundtrack_volume: z.number().default(100),
  title: z.string(),
  caption: z.string(),
  scenes: z.array(components.DraftScene$inboundSchema).optional(),
  quiz: z.lazy(() => Quiz$inboundSchema).optional(),
  ad: z.lazy(() => Ad$inboundSchema).optional(),
  voice_id: z.string().optional(),
  soundtrack_id: z.string().optional(),
  publish_at: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "content_type": "contentType",
    "image_style_id": "imageStyleId",
    "image_model": "imageModel",
    "image_quality": "imageQuality",
    "image_style_raw_mode": "imageStyleRawMode",
    "image_style_custom_prompt": "imageStyleCustomPrompt",
    "animation_model": "animationModel",
    "animation_model_preset": "animationModelPreset",
    "connection_ids": "connectionIds",
    "aspect_ratio": "aspectRatio",
    "voice_playback_rate": "voicePlaybackRate",
    "voice_volume": "voiceVolume",
    "soundtrack_playback_rate": "soundtrackPlaybackRate",
    "soundtrack_volume": "soundtrackVolume",
    "voice_id": "voiceId",
    "soundtrack_id": "soundtrackId",
    "publish_at": "publishAt",
  });
});

/** @internal */
export type CreateVideoRequestBody$Outbound = {
  content_type: string;
  locale: string;
  image_style_id?: string | undefined;
  image_model?: string | undefined;
  image_quality?: string | undefined;
  image_style_raw_mode?: boolean | undefined;
  image_style_custom_prompt?: string | undefined;
  animation_model?: string | undefined;
  animation_model_preset?: string | undefined;
  connection_ids: Array<string>;
  aspect_ratio: string;
  voice_playback_rate: number;
  voice_volume: number;
  soundtrack_playback_rate: number;
  soundtrack_volume: number;
  title: string;
  caption: string;
  scenes?: Array<components.DraftScene$Outbound> | undefined;
  quiz?: Quiz$Outbound | undefined;
  ad?: Ad$Outbound | undefined;
  voice_id?: string | undefined;
  soundtrack_id?: string | undefined;
  publish_at?: string | undefined;
};

/** @internal */
export const CreateVideoRequestBody$outboundSchema: z.ZodType<
  CreateVideoRequestBody$Outbound,
  z.ZodTypeDef,
  CreateVideoRequestBody
> = z.object({
  contentType: ContentType$outboundSchema.default("Custom"),
  locale: CreateVideoLocale$outboundSchema.default("auto"),
  imageStyleId: z.string().optional(),
  imageModel: ImageModel$outboundSchema.optional(),
  imageQuality: ImageQuality$outboundSchema.optional(),
  imageStyleRawMode: z.boolean().optional(),
  imageStyleCustomPrompt: z.string().optional(),
  animationModel: AnimationModel$outboundSchema.optional(),
  animationModelPreset: AnimationModelPreset$outboundSchema.optional(),
  connectionIds: z.array(z.string()),
  aspectRatio: AspectRatio$outboundSchema.default("9:16"),
  voicePlaybackRate: z.number().default(100),
  voiceVolume: z.number().default(100),
  soundtrackPlaybackRate: z.number().default(100),
  soundtrackVolume: z.number().default(100),
  title: z.string(),
  caption: z.string(),
  scenes: z.array(components.DraftScene$outboundSchema).optional(),
  quiz: z.lazy(() => Quiz$outboundSchema).optional(),
  ad: z.lazy(() => Ad$outboundSchema).optional(),
  voiceId: z.string().optional(),
  soundtrackId: z.string().optional(),
  publishAt: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    contentType: "content_type",
    imageStyleId: "image_style_id",
    imageModel: "image_model",
    imageQuality: "image_quality",
    imageStyleRawMode: "image_style_raw_mode",
    imageStyleCustomPrompt: "image_style_custom_prompt",
    animationModel: "animation_model",
    animationModelPreset: "animation_model_preset",
    connectionIds: "connection_ids",
    aspectRatio: "aspect_ratio",
    voicePlaybackRate: "voice_playback_rate",
    voiceVolume: "voice_volume",
    soundtrackPlaybackRate: "soundtrack_playback_rate",
    soundtrackVolume: "soundtrack_volume",
    voiceId: "voice_id",
    soundtrackId: "soundtrack_id",
    publishAt: "publish_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateVideoRequestBody$ {
  /** @deprecated use `CreateVideoRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateVideoRequestBody$inboundSchema;
  /** @deprecated use `CreateVideoRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateVideoRequestBody$outboundSchema;
  /** @deprecated use `CreateVideoRequestBody$Outbound` instead. */
  export type Outbound = CreateVideoRequestBody$Outbound;
}

export function createVideoRequestBodyToJSON(
  createVideoRequestBody: CreateVideoRequestBody,
): string {
  return JSON.stringify(
    CreateVideoRequestBody$outboundSchema.parse(createVideoRequestBody),
  );
}

export function createVideoRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateVideoRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateVideoRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateVideoRequestBody' from JSON`,
  );
}
